Лабораторная 2

В функциональном программировании функции -- значения первого сорта (first-class values).
Т.е. их можно свободно передавать в качестве аргументов, возвращать, хранить в списках/кортежах/... и т.д.

Лямбда-выражения возвращают функции:
fun
    (Pattern11,...,Pattern1N) [when GuardSeq1] ->
        Body1;
    ...;
    (PatternK1,...,PatternKN) [when GuardSeqK] ->
        BodyK
end
или
fun Module:Name/Arity (Module можно опустить, если функция определена в текущем модуле или импортирована)

Например:
1> PowerOfTwo = fun(X) -> math:pow(2, X) end.
#Fun<erl_eval.6.56006484>
2> PowerOfTwo(2).
4.0

3> TempConvert = fun({c,C}) -> {f, 32 + C*9/5};
3>                  ({f,F}) -> {c, (F-32)*5/9}
3>               end.
#Fun<erl_eval.6.37519123>

4> Sum = fun lists:sum/1.
#Fun<lists.sum.1>

Лямбда-выражения могут использовать уже определённые переменные:

foo(X) ->
  Add = fun(Y) -> X+Y end,
  Add(10)
6> funs:foo(3)
13

Т.е. это замыкания.

Переменные в аргументах лямбда-выражения перекрывают внешние аргументы с тем же именем:

bar() ->
  X = 2,
  Bump = fun(X) -> X+1 end,
  Bump(10).
5> funs:bar()
11

А в теле -- ошибка:

baz() ->
  X = 2,
  Fun = fun() ->
             X = 3,
             X+1 
         end,
  Fun(10).


Функции, которые принимают функции как аргументы или возвращают их -- функции высшего порядка. 
Например, функция сортировки может принимать на вход список данных и функцию сравнения
элементов.


Много полезных ФВП определено в модуле lists:
all(Predicate, List)
  true, если Predicate (функция из элементов списка в true/false) возвращает true на всех элементах List
  false, если Predicate возвращает false на каком-то элементе List

  lists:all(fun(X) -> X > 0 end, [1,-1,2]) => false
any(Predicate, List)
  true, если Predicate (функция из элементов списка в true/false) возвращает true на каком-то элементе List
  false, если Predicate возвращает false на всех элементах List
  
  lists:any(fun(X) -> X > 0 end, [1,-1,2]) => true
dropwhile(Predicate, List)
  Выбрасывает из List все начальные элементы, на которых Predicate возвращает true, и возвращает то, что осталось
  (т.е. часть списка, которая начинается с первого элемента, на котором предикат вернул false

  lists:dropwhile(fun(X) -> X > 0 end, [1,-1,2]) => [-1, 2]
filter(Predicate, List)
  Возвращает список, состоящий только из тех элементов List, на которых Predicate возвращает true

  lists:filter(fun(X) -> X > 0 end, [1,-1,2]) => [1, 2]
foldl(Fun, Accumulator, List)
  Сворачивает список. Fun -- функция от двух аргументов, первый -- элемент из списка, второй -- значение Accumulator,
  возвращает новое значение для Accumulator. Когда в списке не остаётся элементов, foldl возвращает значение Accumulator.
  Реализацию см. в lists2.erl. foldr -- аналогично, но пробегает список справа налево.

  lists:foldl(fun(X, Acc) -> X + Acc end, 0, [1,2,3]) => 6
foreach(Fun, List)
  Вызывает Fun на каждом элементе в списке и отбрасывает результат
map(Fun, List)
  Возвращает список, состоящий из результатов применения Fun к каждому элементу List

  lists:map(fun(X) -> X > 0 end, [1,-1,2]) => [true, false, true]
partition(Predicate, List)
  Возвращает пару списков. Первый состоит из элементов List, на которых Predicate вернул true, второй -- из тех, на которых он вернул false.

  lists:partition(fun(X) -> X > 0 end, [1,-1,2]) => {[1,2], [-1]}
sort(Fun, List)
  Возвращает список List, отсортированный с помощью отношения порядка Fun. Fun(X, Y) возвращает true, если X меньше или равно Y, и false
  в противном случае.

  lists:sort(fun(X, Y) -> length(X) <= length(Y), [[1],[1,1],[]]) => [[],[1],[1,1]]
takewhile(Predicate, List)
  Возвращает максимальный начальный отрезок List, на всех элементах которого Predicate возвращает true

  lists:takewhile(fun(X) -> X > 0 end, [1,-1,2]) => [1]
zipwith(Fun, List1, List2)
  Возвращает список, состоящий из результатов применения Fun к парам элементов List1 и List2, стоящим на одинаковых местах. 
  Если один из списков длиннее, "лишние" элементы отбрасываются.

  lists:zipwith(fun(X, Y) -> X+Y end, [1,2,3,4], [4,5,6]) => [5,7,9]
И т.д.

ФВП позволяют программисту определять собственные управляющие инструкции. В Эрланге нет ?: из C-подобных языков, for или while, но мы можем их добавить сами.
Примеры в control.erl

Ещё пример: работа с файлами. Можем в каждой функции открывать и закрывать файл вручную:

foo() ->
    Fd = file:open("foo.txt"),
    ... %% что-то делаем
    Result = ...
    file:close(Fd),
    Result.

bar(FileName) ->
    Fd = file:open(FileName),
    ... %% что-то делаем
    Result = ...
    file:close(Fd),
    Result.

А можем вынести в отдельнубю функцию:

with_file(Fun, FileName) ->
    Fd = file:open(FileName),
    Result = Fun(Fd),
    file:close(Fd),
    Result.

foo1() -> withFile(
            fun(Fd) -> ...
            end, 
            "foo.txt")

bar1(FileName) -> withFile(
            fun(Fd) -> ...
            end, 
            FileName)

Тут выигрыш кажется небольшим, но 
1) мы в принципе не можем забыть закрыть файл. Если это делается не в начале и в конце функции (как в foo/1 и bar/1), а где-то в середине большой функции, может быть важно.
2) что случится, если функция Fun выкинет исключение? Файл не закроется! Теперь это можно исправить только в одном месте with_file, а не в каждой функции по отдельности.
3) то, что мы абстрагируем, может быть куда больше и сложнее, чем открыть/закрыть файл.
См. пример в file_io.html (http://www.erlang.org/examples/klacke_examples/index.html)
