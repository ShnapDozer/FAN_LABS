Обозначения типов в программах на Erlang можно найти в главе 6 Reference Manual (http://www.erlang.org/doc/reference_manual/typespec.html). В заданиях применяется несколько упрощённая система обозначений, но рекомендуется познакомиться с настоящими обозначениями и применить их в задании 2.

БДП -- бинарное дерево поиска -- такое бинарное дерево (см. bin_tree.erl), у которого в левом поддереве любой вершины все данные меньше, чем в этой вершине, а в правой все данные больше. В задании 1 во всех вариантах деревья (как в аргументах, так и в возвращаемых значениях) -- БДП. 

В заданиях 1 и 3 запрещено сопоставлять с образцом непосредственно значения абстрактных типов! То есть вместо

case Tree of 
  empty -> ...
  {node, Data, Left, Right} -> ...
end

следует использовать

case view(Tree) of 
  empty -> ...
  {node, Data, Left, Right} -> ...
end

Это позволяет (теоретически) использовать другую реализацию этого интерфейса.

В задании 2 под интерфейсом понимается набор функций, необходимый для создания значений определяемоготипа и работы с ними. Для каждой функции должны быть указаны типы аргументов и возвращаемых значений, а также по возможности полно описано поведение. Напишите также набор тестов, которые должны выполняться для реализаций. См. stack.erl для примера интерфейса и тестов АТД "стек".

Максимальная оценка за 1 реализацию в задании 4 -- 8 баллов.

Вариант 1

1. Реализуйте функцию split(bin_tree, any) -> {bin_tree, bin_tree}. split(Tree, X) возвращает пару {TreeLT, TreeGT}; TreeLT содержит все элементы Tree, меньшие X, а TreeGT -- все элементы, большие X.

2. Разработайте интерфейс для абстрактного типа данных "множество" (см. http://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%28%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%29). Множество позволяет хранить произвольное число значений без определённого порядка, при этом каждое значение хранится не более одного раза. 

3. Реализуйте над этим интерфейсом функцию is_subset(set, set) -> bool. is_subset(Set1, Set2) возвращает true, если Set1 -- подмножество Set2 (т.е. все элементы Set1 содержатся в Set2).

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса. Каждая реализация в своём модуле.


Вариант 2

1. Реализуйте функцию merge(bin_tree, bin_tree) -> bin_tree. merge(Tree1, Tree2) возвращает дерево, содержащее все элементы Tree1 и Tree2.

2. Разработайте интерфейс для абстрактного типа данных "мультимножество" (см. http://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE). Мультимножество позволяет хранить произвольное число значений без определённого порядка, при этом для каждого значение хранится также число раз, которое этот объект входит в мультимножество).

3. Реализуйте над этим интерфейсом функцию union(multiset, multiset) -> bool. union(Multiset1, Multiset2) возвращает мультимножество, содержащее все элементы Multiset1 и Multiset2, причём кратности элементов складываются (т.е. если X содержится 2 раза в MS1 и 3 раза в MS2, то оно содержится в union(MS1, MS2) 5 раз).

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса.


Вариант 3

1. Реализуйте функцию flatten(bin_tree) -> list. flatten(Tree) возвращает список всех данных в дереве в порядке возрастания.

2. Разработайте интерфейс для абстрактного типа данных "словарь" (см. http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2). Словарь позволяет хранить произвольное число пар ключ-значение без определённого порядка, при этом две пары с одним ключом одновременно не допускаются.

3. Реализуйте над этим интерфейсом функцию all_values(dictionary) -> [any]. all_values(Dict) возвращает список всех значений в словаре.

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса.


Вариант 4

1. Реализуйте функцию count_leaves(bin_tree) -> integer. count_leaves(Tree) возвращает число листьев дерева (т.е. вершин, у которых оба поддерева -- пустые).

2. Разработайте интерфейс для абстрактного типа данных "очередь с приоритетом" (см. http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC). Очередь с приоритетом позволяет хранить пары (значение, приоритет), при этом каждое значение может храниться несколько раз (в том числе с одинаковым приоритетом) и поддерживает операцию извлечения пары с минимальным приоритетом.

3. Реализуйте над этим интерфейсом функцию to_list(priority_queue) -> [any]. to_list(Queue) возвращает список всех значений, содержащихся в Queue, в порядке возрастания приоритета.

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса.

Дополнительное задание (для всех вариантов): 

5. Оцените алгоритмическую сложность реализаций, созданных в задании 4. 
