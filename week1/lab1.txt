Basic Erlang II
Function Calls
Modules

Basic Erlang III
Starting the System
Shell Commands
Erlang Mode for Emacs

1. Оболочка

В оболочке можно писать любые выражения и видеть их результат.
Не забывать точки после выражений! Если точки нет, то ввод команды продолжается, пока она не появится.
Можно это увидеть по сохранению номера команды.

	1> help(). %% помощь
	2> h(). %% История (последние двадцать команд).
	3> q(). %% вызод из оболочки

2. Типы данных
2.1. Числа

2.1.1. Целые числа
Неограниченная величина! (Не 32 бита, не 64 бита, и т.д.) 
	1> 124. %% Понятно что
	124
	2> 2#1001. %% Число 1001 в двоичной системе счисления
	9
	3> $a. %% ASCII-код символа a
	97
	
2.1.2. Числа с плавающей точкой.
64 бита, стандартное поведение, проблемы с округлением и т.д.

2.1.3. Арифметика.
	+, -, *, <, >, и т.д. как обычно
	
	4> 5/3. %% деление как в математике, не как в C-подобных языках
	1.6666666666666667
	5> 5 div 3.
	1
	6> 5 rem 3.
	2
	7> 5 == 3.
	false
	8> 5 /= 3. %% проверка неравенства
	true
    9> 5 != 3.
    * 1: syntax error before: '='
	10> 1 == 1.0.
	true
	11> 1 =:= 1.0. %% равенство без приведения типов
	false
	
2.2 Атомы
Имена сами по себе. Как и числа: значение атома -- атом. Единственная операция -- сравнение. Порядок алфавитный.
Последовательность символов: 
либо начинается со строчной буквы и содержит только буквы, цифры, _, @;
либо окружена апострофами.
	1> abc.
	abc
	2> 'abc_123_CDE'.
	abc_123_CDE
	3> 'using spaces'.
	'using spaces'
	4> 'lowercaseQuote'.
	lowercaseQuote
	5> '\n\n'.
	'\n\n'
	6> '1
	6> 2
	6> 3
	6> 4'.
	'1\n2\n3\n4'
	7> 'funny characters in quotes: !"?$%^&*()-='.
	'funny characters in quotes: !"?$%^&*()-='
	8> '1+2+3'.
	'1+2+3'
	9> 'missing a full stop.'
	9> .
	'missing a full stop.'
	10> ab == bc.
	false
	11> ab == 'ab'.
	true
	12> ab < bc.   
	true
true и false -- просто атомы. С точки зрения языка никакой особой роли не играют, только с точки зрения библиотек.
Также: ok, value, error, 'EXIT', и т.д.

2.2.1. Булевы операции
and, or, xor, not -- обычные
andalso, orelse -- shortcut-операции (если первого аргумента достаточно, второй не считается).

2.3. Кортежи
Составное значение.
{Item1, Item2, Item3} -- кортеж из трёх элементов, каждый может сам быть сложным, и т.д.
Пример:
	1> Person = {person,
	1>	{name, joe},
	1>	{height, 1.82},
	1>	{footsize, 42},
	1>	{eyecolour, brown}}.
	{person,{name,joe},
			{height,1.82},
			{footsize,42},
			{eyecolour,brown}}

Для фиксированного количества элементов. Как извлекать данные -- чуть позже.

2.4. Списки
[Item1, Item2, Item3]
[] %% пустой список.
Для произвольного количества элементов.

Дешёвая операция добавления в начало списка:
	1> [1 | [2,3,4]].
	[1,2,3,4]
В конец списка добавлять дорого!

Все настоящие (proper) списки:
[] или [Element|List], где List -- настоящий список
Element называется головой списка, List -- хвостом

++ приписывание списков
-- разность списков
Обе операции довольно дорогие (см. лекции). Если можете обойтись добавлением элемента в начало -- обходитесь.
	2> [1,2,3,4,1,2,3,4] ++ [1,2,2,3,3].
	[1,2,3,4,1,2,3,4,1,2,2,3,3]
	3> [1,2,3,4,1,2,3,4] -- [1,2,2,3,3].
	[4,1,4]
	4> [1,2,3,4,1,2,3,4] -- [1,2,2,3,3,5].
	[4,1,4]

2.4.1. Строки
Это списки ASCII-кодов символов (см. раздел 2.1.1).  Если список состоит из только целых чисел -- кодов пчатных символов, то оболочка печатает как строку.
И всё!
	5> [96,97,98].
	"`ab"
	6> [$e,$r,$l,$a,$n,$g].
	"erlang"
	7> "abc" ++ "def".
	"abcdef"

3. Сопоставление с образцом
3.1. Переменные.
Так же, как первый случай атомов, только начинается с заглавной буквы или _
X, Var, _Something -- переменные.

Объявлять не нужно.

После связывания переменной со значением изменить её нельзя!
	1> X = 3.
	3
	2> X = 5. %% Это превращается в 3 = 5!
	** exception error: no match of right hand side value 5
	
_ -- анонимная переменная. Ей значение никогда на самом деле не привязывается.

3.1.1. Команды оболочки для работы с переменными:
	b(). %% показывает значения всех связанных переменных
	f(). %% забывает значения всех связанных переменных (только в оболочке! Внутри программы на Erlang этого сделать нельзя!)
	f(X). %% забывает значение связанной переменной X

3.2. Сопоставление:
Pattern = Expression

В Pattern могут быть несвязанные переменные, в Expression всё определено.

Результат -- успех или неудача. В случае неудачи выкидывается ошибка.

Присвоение значений переменным и проверка структуры _одновременно_.
		
Pattern 	Expression 		        Результат
{X,abc}   =	{123,abc} 				Успех: X => 123
{X,Y,Z}   =	{222,def,"cat"} 		Успех: X => 222, Y => def, Z => "cat"
{X,Y} 	  =	{333,ghi,"cat"} 		Неудача: разное количество элементов в кортежах
X 		  =	true 					Успех: X => true
{X,_,X}   =	{{abc,12},42,{abc,12}} 	Успех: X => {abc,12}
{X,Y,X}   =	{{abc,12},42,true} 		Неудача: X одновременно {abc,12} и true
[H|T] 	  =	[1,2,3,4,5] 			Успех: H => 1, T => [2,3,4,5]
[H|T] 	  =	"cat" 					Успех: H => 99, T => "at"
[H|T]     = []                      Неудача
[A,B,C|T] = [a,b,c,d,e,f] 			Успех: A => a, B => b, C => c, T => [d,e,f]
{_, {_, Name}, {_, Height}, _, _} = Person (см. выше) Успех: Name => joe, Height => 1.82
2         = 1+1                     Успех

3.3. case
	case Expression of
		Pattern1 [when Guard1] -> Expr_seq1;
		Pattern2 [when Guard2] -> Expr_seq2;
		...
		PatternLast -> Expr_seq_last %% нет точки с запятой!
	end

Выполняется по очереди Pattern1 = Expression, Pattern2 = Expression и т.д., пока не получится успех.
Если успех, например, в Pattern3 = Expression, то выполняется Expr_seq3. В Expr_seq3 можно использовать переменные, связанные в Pattern3.
Если все сопоставления неудачные -- это ошибка.

Последний образец может быть _, тогда сопоставление точно удаётся

Есть ещё if, но довольно непривычный. Проще пока использовать
	case Condition of
		true  -> ...;
		false -> ...
	end

3.4 Охрана (guard)
После when в case и определениях функций. Доп. условия на переменные.
Допускает ограниченный набор действий:
Арифметика
Операторы сравнения
Проверка типов: is_boolean(X), is_number(X), is_integer(X), is_float(X), is_atom(X), is_pid(X), is_tuple(X), is_list(X)
Может быть несколько условий: "," действует как "и", ";" как "или"
Подробности см. в документации

4. 
Файлы, модули

Модуль с названием ModName должен быть в файле ModName.erl
ModName -- атом первого типа, т.е. начинается со строчной буквы!

-module(ModName).
-import(Mod, [Fun/Arity]). %% Импортировать функцию Fun с Arity аргументами из Mod.
-export([Fun/Arity]). %% Экспортировать функцию Fun с Arity аргументами.

function(Pattern1) when Guard1 -> ...;
function(Pattern2) -> ...; %% ; между клозами
function(Pattern3) -> ... . %% . в конце

4.1.
Вызов функции
FunName(Arg1, Arg2, ...) %% если импортирована или определена в текущем модуле
или
ModuleName:FunName(Arg1, Arg2, ...)

4.1.
Команды оболочки для работы с модулями
	pwd(). %% печатает рабочую директорию
	cd(Dir). %% Войти в директорию Dir. Использовать /, не \ (escape-символ)!
	c(Module). %% Скомпилировать модуль Module (он должен быть в файле Module.erl)

Написать функцию weekDay({D,M,Y}) top-down